# PHONY targets have no dependencies and they will be built unconditionally upon request.
.PHONY: all-generated-artifacts up up-detached logs-follow down down-full rm-state-volumes rm-node-modules rm-generated-artifacts rm-webserver-env rm-chaincode-docker-resources clean

# This is also hardcoded in .env, so if you change it here, you must change it there.  Note that
# it must be in all-lowercase, as docker-compose changes it to lowercase anyway.
COMPOSE_PROJECT_NAME := fabricwebapp

# Default make rule
all:
	@echo "See README.md for info on make targets."

# Creates everything under the generated-artifacts directory.
all-generated-artifacts: generated-artifacts/crypto-config generated-artifacts/mychannel.tx generated-artifacts/orderer.genesis.block

# Creates everything under the generated-artifacts/crypto-config directory (all cryptographic materials)
generated-artifacts/crypto-config: source-artifacts/crypto-config.yaml
	mkdir -p generated-artifacts
	$(GOPATH)/src/github.com/hyperledger/fabric/build/bin/cryptogen generate --output=generated-artifacts/crypto-config --config=source-artifacts/crypto-config.yaml
	# These dirs should be but aren't generated by cryptogen
	mkdir -p generated-artifacts/crypto-config/ordererOrganizations/example.com/msp/intermediatecerts
	mkdir -p generated-artifacts/crypto-config/ordererOrganizations/example.com/msp/crls
	mkdir -p generated-artifacts/crypto-config/peerOrganizations/org0.example.com/msp/intermediatecerts
	mkdir -p generated-artifacts/crypto-config/peerOrganizations/org0.example.com/msp/crls
	mkdir -p generated-artifacts/crypto-config/peerOrganizations/org1.example.com/msp/intermediatecerts
	mkdir -p generated-artifacts/crypto-config/peerOrganizations/org1.example.com/msp/crls

# Creates the generated-artifacts/mychannel.tx file (channel configuration transaction)
generated-artifacts/mychannel.tx: source-artifacts/configtx.yaml generated-artifacts/crypto-config
	mkdir -p generated-artifacts
	cd source-artifacts && $(GOPATH)/src/github.com/hyperledger/fabric/build/bin/configtxgen -profile TwoOrgsChannel -outputCreateChannelTx ../generated-artifacts/mychannel.tx -channelID mychannel

# Creates the generated-artifacts/orderer.genesis.block file (the first block in the chain; contains configuration data)
generated-artifacts/orderer.genesis.block: source-artifacts/configtx.yaml generated-artifacts/crypto-config
	mkdir -p generated-artifacts
	cd source-artifacts && $(GOPATH)/src/github.com/hyperledger/fabric/build/bin/configtxgen -profile TwoOrgsOrdererGenesis -outputBlock ../generated-artifacts/orderer.genesis.block

# Bring up all services (and necessary volumes, networks, etc)
up: all-generated-artifacts
	docker-compose up --abort-on-container-exit

# Bring up all services (and necessary volumes, networks, etc) in detached mode
up-detached: all-generated-artifacts
	docker-compose up -d --abort-on-container-exit

# Follow the output of the logs
logs-follow:
	docker-compose logs --follow --tail="all"

# Bring down all services (delete associated containers, networks, but not volumes)
down:
	docker-compose down

# Bring down all services and volumes (delete associated containers, networks, AND volumes)
down-full:
	docker-compose down -v

# Shows all non-source resources that this project created that currently still exist.
# The shell "or" with `true` is so we don't receive the error code that find/grep produces when there are no matches.
show-all-generated-resources:
	find generated-artifacts || true
	@echo ""
	docker ps -a | grep example.com || true
	@echo ""
	docker volume ls | grep $(COMPOSE_PROJECT_NAME) || true
	@echo ""
	docker images | grep -E "$(COMPOSE_PROJECT_NAME)|example.com" || true

# Delete the "state" volumes -- tmp dir (which contains the webserver's key store) and HFC key/value store in
# home dir This can be done after `make down` to reset things to a "clean state", without needing to recompile go code or
# run `npm install` from scratch.  The shell "or" with `true` is so this command never fails.
rm-state-volumes:
	docker volume rm $(COMPOSE_PROJECT_NAME)_webserver_tmp $(COMPOSE_PROJECT_NAME)_webserver_homedir $(COMPOSE_PROJECT_NAME)_ca_org0_volume $(COMPOSE_PROJECT_NAME)_ca_org1_volume || true

# Delete the node_modules dir, in case things get inexplicably screwy and you just feel like you have to nuke something.
# The shell "or" with `true` is so this command never fails.
rm-node-modules:
	docker volume rm $(COMPOSE_PROJECT_NAME)_webserver_homedir_node_modules || true

# Delete the generated-artifacts dir.  The shell "or" with `true` is so this command never fails.
rm-generated-artifacts:
	rm generated-artifacts -rf || true

# Delete the docker image that the webserver uses.  The shell "or" with `true` is so this command never fails.
rm-webserver-env:
	docker rmi $(COMPOSE_PROJECT_NAME)_webserver-env:v0.0 || true

# Delete the containers and images created by the peers that run chaincode.  This will be necessary if the chaincode
# is changed, because new docker images will have to be built with the new chaincode.  If the chaincode has not changed,
# then this is not necessary.  The semicolons are to run the commands sequentially without heeding the exit code.  The
# command `true` is called last so that the make rule is always considered to have succeeded.
rm-chaincode-docker-resources:
	docker rm dev-peer0.org0.example.com-mycc-v0 \
	          dev-peer1.org0.example.com-mycc-v0 \
	          dev-peer0.org1.example.com-mycc-v0 \
	          dev-peer1.org1.example.com-mycc-v0; \
	docker rmi dev-peer0.org0.example.com-mycc-v0 \
	           dev-peer1.org0.example.com-mycc-v0 \
	           dev-peer0.org1.example.com-mycc-v0 \
	           dev-peer1.org1.example.com-mycc-v0; \
	true

# Deletes all non-source resources that this project created that currently still exist.  This should
# reset the project back to a "clean" state.
rm-all-generated-resources:
	$(MAKE) down
	$(MAKE) rm-state-volumes rm-node-modules rm-generated-artifacts rm-chaincode-docker-resources
	$(MAKE) rm-webserver-env

# Alias for rm-all-generated-resources.
clean: rm-all-generated-resources
